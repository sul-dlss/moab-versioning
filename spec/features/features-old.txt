
----

h3.  Feature - _Version Metadata object creation_
  bq. In order to: flexibly create in-memory objects containing the metadata
  bq. The application needs to: initialize objects and assign values to object variables
  h4.  scenario - _Create a Version Metadata object_
    bq. given: a druid
    bq. action: call class initialize method
    bq. outcome: new VersionMetadata object
  h4.  scenario - _Create a VersionIdentity object_
    bq. given: version number, label, timestamp, description
    bq. action: call class initialize method
    bq. outcome: new VersionIdentity object
  h4.  scenario - _Create a VersionData object_
    bq. given: no parameters
    bq. action: call class initialize method
    bq. outcome: new VersionData object
  h4.  scenario - _Create a DataGroup object_
    bq. given: group name and base directory
    bq. action: call class initialize method
    bq. outcome: new DataGroup object
  h4.  scenario - _Create a DataFile object_
    bq. given: file name, size, last modification date, signature
    bq. action: call class initialize method
    bq. outcome: new DataFile object
  h4.  scenario - _Create a Checksum object_
    bq. given: digest type, value
    bq. action: call class initialize method
    bq. outcome: new Checksum object
  h4.  scenario - _Raise exception if call initialze with incorrect variable name_
    bq. given: incorrect variable name
    bq. action: call class initialize method
    bq. outcome: should raise exception

----

h3.  Feature - _Fixity verification_
  bq.  In order to: Verify that digital object files have not been corrupted
  bq.  The application needs to: re-harvest file properties and compare against the manifest
  h4.  scenario - _Verify file count_
    bq. given: a version manifest and file folder locations of all data groups
    bq. action: the application needs to inventory the files in each file folder
    bq.       : compare file names and counts against the manifest
    bq. outcome: A human & machine readable report summarizing verification result
    bq.        : the details of any discrepancies
  h4.  scenario - _Verify file properties_
    bq. given: a version manifest and file folder locations of all data groups
    bq. action: the application needs to harvest metadata from each file folder
    bq.       : compare file size and fixity properties against the manifest
    bq. outcome: A human & machine readable report summarizing verification result
    bq.        : the details of any discrepancies

----

h3.  Feature - _Harvest file properties from a file folder_
  bq. In order to: automate the generation of a data group object and its child data file objects
  bq. The application needs to: traverse a directory tree and capture file metadata and checksums
  h4.  scenario - _Capture properties of all files in a content directory_
    bq. given: new data group name, path to content directory
    bq. action: traverse the directory and capture file metadata
    bq. outcome: gnerate new data group and its child data file objects

----

h3.  Feature - _Feature: Version Metadata Serialization_
  bq. In order to: preserve the version metadata held by in-memory objects
  bq. The application needs to: generate a byte-stream rendition of the metadata for disk storage
    bq. given: values for version identification properties
    bq. action: the application initializes the version metadata object
  h4.  scenario - _Serialize version metadata to a hash_
    bq. action: a call the object's to_hash method'
    bq. outcome: produces a hash containing all the version metadata
  h4.  scenario - _should serialize version metadata to XML_
    bq. action: a call the object's to_xml method'
    bq. outcome: produces a XML document containing all the version metadata
  h4.  scenario - _should serialize version metadta to JSON_
    bq. action: a call the object's to_json method'
    bq. outcome: produces a JSON document containing all the version metadata

----

h3.  Feature - _Generate sample version metadata output_
  bq. In order to: provide samples of version metadata datastreams
  bq. The application needs to: harvest file properties and serialize the objects created
    bq. given: the location of sample files
    bq. action: the application initializes the version metadata object
  h4.  scenario - _Serialize version metadata to a hash_
    bq. action: a call the object's to_hash method'
    bq. outcome: produces a hash containing all the version metadata
  h4.  scenario - _Serialize version metadata to XML_
    bq. action: a call the object's to_xml method'
    bq. outcome: produces a XML document containing all the version metadata
  h4.  scenario - _Serialize version metadata to JSON_
    bq. action: a call the object's to_json method'
    bq. outcome: produces a JSON document containing all the version metadata

----

h3.  Feature - _Version Metadata file parsing_
  bq. In order to: re-create an in-memory object representation of serialized version metadata
  bq. The application needs to: read in and parse a XML instance containing version metadata
  h4.  scenario - _Parse an existing XML file_
    bq. given: an XML file containing serialized versionMetadata
    bq. action: parse the file and transfer data to ruby objects
    bq. outcome: an in-memory representation of the versionMetadata
  h4.  scenario - _Round-trip a version manifest_
    bq. given: an in-memory versionMetadata object
    bq. action: serialize the versionMetadata to XML
    bq.       : parse the XML into a new versionManifest object
    bq. outcome: the object created should have the same properties as the original object

----

h3.  Feature - _Compare versions_
  bq.  In order to: determine what changes are present in a new version
  bq.  The application needs to: compare versionMetadata instances
  h4.  scenario - _Compare hashes of two versionMetadata objects_
    bq. given: two versionMetadata files
    bq. action: parse the XML to create in-memory objects
    bq.       : generate hashs of both objects
    bq.       : compare hashes
    bq. outcome: a report of which files have changed
  h4.  scenario - _Figure out which files are renamed_
    bq. given: two version manifests
    bq. action: compare file group inventories
    bq. outcome: a report of which files have been renamed
  h4.  scenario - _Figure out which files are added_
    bq. given: two version manifests
    bq. action: compare file group inventories
    bq. outcome: a report of which files have been added
  h4.  scenario - _Figure out which files are deleted_
    bq. given: two version manifests
    bq. action: compare file group inventories
    bq. outcome: a report of which files have been deleted
  h4.  scenario - _Figure out which files are modified_
    bq. given: two version manifests
    bq. action: compare file group inventories
    bq. outcome: a report of which files have been modified
  h4.  scenario - _Figure out which files were inserted in a sequence_
    bq. given: two version manifests
    bq. action: compare file group inventories
    bq. outcome: a report of which files were inserted and which filenames were incremented
  h4.  scenario - _Aggregate all version changes_
    bq. given: two version manifests
    bq. action: compare file group inventories
    bq. outcome: a report of which files have been renamed, added, deleted, and modified

----

h3.  Feature - _Accessioning of a new digital object version_
  bq.  In order to: incorporate a new version into the DOR workflow
  bq.  The application needs to: obtain version identity information
  h4.  scenario - _Accession the first version or a new full version_
    bq. given: a objectId (druid)
    bq.      : an indication whether this is a new object or a new version
    bq.      : the version label and full description
    bq.      : information about the previous version, if any
    bq.      : a folder containing a set of files
    bq. action: verify whether object or version already exists
    bq.       : validate the version number and other identity information
    bq.       : harvest the file properties for all files being submitted
    bq. outcome: submission of the accessioning package
    bq.        : transfer of the package to DOR workspace
    bq.        : initiate DOR workflow
  h4.  scenario - _Accession a new version with subset of files_
    bq. given: a objectId (druid)
    bq.      : an indication whether this is a new object or a new version
    bq.      : the version label and full description
    bq.      : a folder containing a set of files
    bq. action: verify whether object or version already exists
    bq.       : validate the version number and other identity information
    bq.       : harvest the file properties for all files being submitted
    bq.       : retrieve information about the previous version
    bq.       : verify the completeness of the file set with respect to version differences
    bq. outcome: submission of the accessioning package
    bq.        : transfer of the package to DOR workspace
    bq.        : initiate DOR workflow

----

h3.  Feature - _Process technicalMetadata datastream_
  bq.  In order to: update the technicalMetadata datastream
  bq.  The application needs to: capture JHOVE output for a subset of an object's files
  h4.  scenario - _Generate Jhove output new or modified files_
    bq. given: a report listing new and modified content files
    bq. action: Generate Jhove output for only the new or modified files
    bq. outcome: a report containing Jhove output for selected files
  h4.  scenario - _Merge new Jhove output into technicalMetadata_
    bq. given: a report listing all content file changes
    bq.      : a report containing Jhove output for selected files
    bq. action: delete technicalMetadata entries for changed files
    bq.       : add technicalMetadata entries for new or updated files
    bq. outcome: a new technicalMetadata datastream for the new version

----

h3.  Feature - _Process contentMetadata datastream_
  bq.  In order to: utilize and update the contentMetadata
  bq.  The application needs to: extract and update data from a contentMetadata datastream
  h4.  scenario - _Generate content data group from contentMetadata datastream_
    bq. given: a contentMetadata datastream instance
    bq.      : a new versionMetadata instance
    bq. action: transfer the file-level metadata
    bq. outcome: a fully populated 'content' data group
  h4.  scenario - _Merge new technicalMetadata into contentMetadata_
    bq. given: a report listing all content file changes
    bq.      : a technicalMetadata datastream for the new version
    bq. action: delete contentMetadata entries for changed files
    bq.       : add contentMetadata entries for new or updated files
    bq. outcome: a new contentMetadata datastream for the new version

----

h3.  Feature - _Process provenanceMetadata_
  bq.  In order to: track the event of adding a new version
  bq.  The application needs to: update provenanceMetadata datastream
  h4.  scenario - _Update provenanceMetadata_
    bq. given: existing provenanceMetadata datastream, if any
    bq. action: create or update provenanceMetadata datastream
    bq. outcome: new provenanceMetadata datastream

----

h3.  Feature - _Capture DOR datastream properties_
  bq.  In order to: capture the file-level metadata for an object's DOR datastreams
  bq.  The application needs to: extract the data from DOR
  h4.  scenario - _Generate a metadata DataGroup from DOR datastreams_
    bq. given: a object identifier and a DOR instance
    bq. action: get a list of datastreams
    bq.       : extract file properties
    bq. outcome: a fully populated 'metadata' data group

----

h3.  Feature - _Export a digital object version from DOR_
  bq.  In order to: tranfer files and metadata from DOR to SDR
  bq.  The application needs to: create a Bagit bag containing files and manifests
  h4.  scenario - _Export content and metadata files for a new version_
    bq. given: a versionMetadata datastream and a report of version differences
    bq. action: create a new Bagit container
    bq.       : copy (link) only new or modified files to the data folder
    bq. outcome: Bagit bag containing only new or modified files
  h4.  scenario - _Export content and metadata files for a first version_
    bq. given: a versionMetadata datastream for a first version
    bq. action: create a new Bagit container
    bq.       : copy (link) all files to the data folder
    bq. outcome: Bagit bag containing all files
  h4.  scenario - _Generate Bagit info and manifest files for a new version_
    bq. given: a versionMetadata datastream and a report of version differences
    bq. action: generate a bagit info file
    bq.       : generate manifest files for only the new files
    bq. outcome: bagit.txt and checksum manifest files
  h4.  scenario - _Generate Bagit info and manifest files for a first version_
    bq. given: a versionMetadata datastream
    bq. action: generate a bagit info file
    bq.       : generate manifest files for all files
    bq. outcome: bagit.txt and checksum manifest files

----

h3.  Feature - _Import digital object version to SDR_
  bq.  In order to: ingest a new version of a digital object into SDR
  bq.  The application needs to: process a Bagit bag containing a subset of object files
  h4.  scenario - _Verify bag manifest completeness_
    bq. given: a Bagit bag manifest for each checksum type
    bq.      : the new version's versionMetadata datastream
    bq.      : the previous version's versionManifest (unless first version)
    bq. action: compare new versionMetadata against previous versionMetadata
    bq.       : compare bag manifest against version differences report
    bq. outcome: confirmation that the bag manifest is complete
    bq.        : detailed report of any discrepancies
  h4.  scenario - _Verify versionMetadata completeness_
    bq. given: the Bagit bag manifest for each checksum type
    bq.      : the new version manifest
    bq.      : the existing index of storage location by file signature
    bq. action: compare the versionMetadata's manifest
    bq.       : against the bag manifest and the storage location index
    bq. outcome: confirmation that the versionMetadata manifest is complete
    bq.        : detailed report of any discrepancies
  h4.  scenario - _Verify data file fixity_
    bq. given: the Bagit bag containing a subset of object files
    bq.      : the bag manifest
    bq. action: verify bag manifest against the files in the bag's data folder
    bq. outcome: true/false verification that the bag data files are not corrupted
    bq.        : detailed report of any discrepancies
  h4.  scenario - _Create a new version storage folder_
    bq. given: the Bagit bag containing a subset of object files
    bq.      : the complete versionMetadata datastream
    bq. action: extract the version identity information from the versionMetadata
    bq.       : create the new version's storage folder
    bq.       : and any version-level metadata files, such as logs
    bq. outcome: version storage folder
  h4.  scenario - _Copy unique data files to storage folder of new version_
    bq. given: the Bagit bag containing a subset of object files
    bq.      : the bag manifest
    bq.      : the existing index of storage location by file signature
    bq. action: move files from the bag to the version storage location
    bq.       : update the storage location index
    bq. outcome: version's data folder containing version's files
  h4.  scenario - _Create or update the storage location index_
    bq. given: version's data folder containing version's files
    bq.      : the bag manifest
    bq.      : the existing index of storage location by file signature
    bq. action: update the storage location index
    bq.       : verify the storage location index against all versions
    bq. outcome: revised storage location index

----

h3.  Feature - _Create reconstructed digital object for a version_
  bq.  In order to: disseminate a full or partial copy of a digital object
  bq.  The application needs to: reconstruct the object to its original filenames
  h4.  scenario - _Search for version based on objectId and versionId_
    bq. given: the objectId and versionId
    bq. action: determine the object and version location
    bq. outcome: the versionMetadata for the version
  h4.  scenario - _Search for version based on objectId and timestamp_
    bq. given: the objectId and version timestamp
    bq. action: determine the object and version location
    bq. outcome: the versionMetadata for the version
  h4.  scenario - _Browse for version based on objectId_
    bq. given: the objectId
    bq. action: determine the object location
    bq.       : retrieve copies of all versionMetadata files
    bq. outcome: a list of versions for the object
  h4.  scenario - _Generate a copy of a full version in a temp location_
    bq. given: the version's data folder containing version's files
    bq.      : the versionMetadata manifest
    bq.      : the existing index of storage location by file signature
    bq. action: copy (link) files to the temp location,
    bq.       : using the storage location index to locate files
    bq.       : and the versionMetadata manifest to provide original filenames
    bq. outcome: a temp folder containing the version's files
  h4.  scenario - _Generate a copy of a partial version in a temp location_
    bq. given: the version's data folder containing version's files
    bq.      : the versionMetadata manifest
    bq.      : the existing index of storage location by file signature
    bq.      : the list of desired files to be retrieved
    bq. action: copy (link) selected files to the temp location,
    bq.       : using the storage location index to locate files
    bq.       : and the versionMetadata manifest to provide original filenames
    bq. outcome: a temp folder containing a subset of   the version's files

----

h3.  Feature - _Tape archive_
  bq.  In order to: preseve copies of digital objects to tape
  bq.  The application needs to: archive and retrieve version files
  h4.  scenario - _Set up policies regarding TSM archiving_
    bq. given: the TSM client system
    bq. action: set up a TSM policy domain, policy set, and management class
    bq. outcome: TSM storage managment policy
  h4.  scenario - _Archive a first version of a digital object_
    bq. given: the version folder containing a version's files
    bq. action: do a TSM archive operation of the folder
    bq.       : verify that TSM archive exists (query archive)
    bq. outcome: copies of the version's files should be on tape
    bq.        : TSM log file and 'description' label and date for the archive
  h4.  scenario - _Archive two more versions of the same digital object_
    bq. given: the version folders containing new versions files
    bq. action: do separate TSM archive operations for both versions' folders
    bq.       : verify that TSM archives exists (query archive)
    bq. outcome: copies of the versions' files should be on tape
    bq.        : TSM log file and 'description' label and date for the archive
  h4.  scenario - _Retrieve files of first version_
    bq. given: the 'description' label and date for the archive
    bq. action: retrieve the data from tape to a temp disk location
    bq. outcome: disk folder containing the version's files
  h4.  scenario - _Retrieve files of addtional versions_
    bq. given: the 'description' label and date for the archives
    bq. action: retrieve the data from tape to separate temp disk locations
    bq. outcome: disk folders containing the versions' files
