
{anchor:Serializable}
h2. Class Serializer::Serializable

h4. Description

Some utility methods to facilitate serialization of data fields to Hash, JSON, or YAML shared by all subclasses.
This class assumes that HappyMapper is used for declaration of fields to be serialized.

h4. Data Model
* *[#Serializable] = utility methods to facilitate serialization to Hash, JSON, or YAML*
** [#Manifest] = adds methods for marshalling/unmarshalling data to a persistent XML file format

 
||XML Element||Ruby Class||Inherits From||
|<serializable>|Serializable|Object|

h3. Class Methods
 
h5. Serializer::Serializable.deep_diff
||Method||Return Type||Description||
|deep_diff|Hash|Generate a hash containing the differences between two hashes (recursively descend parallel trees of hashes)|
 
||Parameter||Data Type||Description||
|hashes|Array<Hash>|The hashes to be compared, with optional name tags|
{code:lang=none|title=Ruby Source Code}
def Serializable.deep_diff(*hashes)
  diff = Hash.new
  case hashes.length
    when 4
      ltag, left, rtag, right = hashes
    when 2
      ltag, left, rtag, right = :left, hashes[0], :right, hashes[1]
    else
      raise "wrong number of arguments (expected 2 or 4)"
  end
  (left.keys | right.keys).each do |k|
    if left[k] != right[k]
      if left[k].is_a?(Hash) && right[k].is_a?(Hash)
        diff[k] = deep_diff(ltag, left[k], rtag, right[k])
      else
        diff[k] = Hash.[](ltag, left[k], rtag, right[k])
      end
    end
  end
  diff
end
{code}
 
----

{anchor:Manifest}
h2. Class Serializer::Manifest

h4. Description

Subclass of [#Serializable] that adds methods for marshalling/unmarshalling data
to a persistent XML file format.

h4. Data Model
* [#Serializable] = utility methods to faciliate serialization to Hash, JSON, or YAML
** *[#Manifest] = subclass adds methods for marshalling/unmarshalling data to XML file format*

 
||XML Element||Ruby Class||Inherits From||
|<manifest>|Manifest|Serializer::Serializable|

h3. Class Methods
 
h5. Serializer::Manifest.xml_filename
||Method||Return Type||Description||
|xml_filename|String|Returns the standard filename (derived from the class name) to be used for serializing an object|
 
||Parameter||Data Type||Description||
|filename|String|Optional filename if one wishes to override the default filename|
{code:lang=none|title=Ruby Source Code}
def self.xml_filename(filename=nil)
  if filename
    filename
  else
    cname = self.name.split(/::/).last
    cname[0, 1].downcase + cname[1..-1] + '.xml'
  end
end
{code}
 
h5. Serializer::Manifest.xml_pathname
||Method||Return Type||Description||
|xml_pathname|Pathname|The location of the xml file|
 
||Parameter||Data Type||Description||
|parent_dir|Pathname, String|The location of the directory in which the xml file is located|
|filename|String|Optional filename if one wishes to override the default filename|
{code:lang=none|title=Ruby Source Code}
def self.xml_pathname(parent_dir, filename=nil)
  Pathname.new(parent_dir).join(self.xml_filename(filename))
end
{code}
 
h5. Serializer::Manifest.xml_pathname_exist?
||Method||Return Type||Description||
|xml_pathname_exist?|Boolean|Returns true if the xml file exists|
 
||Parameter||Data Type||Description||
|parent_dir|Pathname, String|The location of the directory in which the xml file is located|
|filename|String|Optional filename if one wishes to override the default filename|
{code:lang=none|title=Ruby Source Code}
def self.xml_pathname_exist?(parent_dir, filename=nil)
  self.xml_pathname(parent_dir, filename).exist?
end
{code}
 
h5. Serializer::Manifest.read_xml_file
||Method||Return Type||Description||
|read_xml_file|Serializable|Read the xml file and return the parsed XML|
 
||Parameter||Data Type||Description||
|parent_dir|Pathname, String|The location of the directory in which the xml file is located|
|filename|String|Optional filename if one wishes to override the default filename|
{code:lang=none|title=Ruby Source Code}
def self.read_xml_file(parent_dir, filename=nil)
  self.parse(self.xml_pathname(parent_dir, filename).read)
end
{code}

{code:lang=none|title=Usage Example}
require 'spec_helper'

feature "Manifest file parsing" do
  # In order to: re-create an in-memory object representation of serialized version metadata
  # The application needs to: read in and parse a XML instance containing version metadata

  background(:all) do
    @fixtures = File.join(File.dirname(__FILE__), '..', 'fixtures')
  end

  scenario "Parse an existing XML file" do
    # given: an signatureCatalog.xml file containing a serialized catalog
    # action: parse the file and transfer data to ruby objects
    # outcome: an in-memory representation of the manifest

    parent_dir = @manifests.join("v1")
    SignatureCatalog.xml_pathname(parent_dir).should == parent_dir.join('signatureCatalog.xml')
    catalog = SignatureCatalog.read_xml_file(parent_dir)
    catalog.should be_instance_of(SignatureCatalog)
    catalog.entries.size.should == 11
  end

end
{code}
 
h5. Serializer::Manifest.write_xml_file
||Method||Return Type||Description||
|write_xml_file|void|Serializize the in-memory object to a xml file instance|
 
||Parameter||Data Type||Description||
|xml_object|Serializable||
|parent_dir|Pathname, String|The location of the directory in which the xml file is located|
|filename|String|Optional filename if one wishes to override the default filename|
{code:lang=none|title=Ruby Source Code}
def self.write_xml_file(xml_object, parent_dir, filename=nil)
  self.xml_pathname(parent_dir, filename).open('w') { |f| f << xml_object.to_xml }
  nil
end
{code}

h3. Instance Methods
 
h5. Serializer::Manifest#write_xml_file
||Method||Return Type||Description||
|write_xml_file|void|Serializize the in-memory object to a xml file instance|
 
||Parameter||Data Type||Description||
|parent_dir|Pathname, String|The location of the directory in which the xml file is located|
|filename|String|Optional filename if one wishes to override the default filename|
{code:lang=none|title=Ruby Source Code}
def write_xml_file(parent_dir, filename=nil)
  self.class.write_xml_file(self, parent_dir, filename)
end
{code}

{code:lang=none|title=Usage Example}
require 'spec_helper'

feature "Feature: Manifest Serialization" do
  # In order to: preserve the manifest metadata held by an in-memory object
  # The application needs to: generate a xml file rendition of the metadata for disk storage

  scenario "should serialize signature catalog metadata to XML" do
    # action: a call the object's write_xml_file method
    # outcome: produces a XML document containing all the catalog metadata

    output_dir = @temp.join('catalog')
    output_dir.mkpath
    catalog_object = SignatureCatalog.read_xml_file(@manifests.join("v1"))
    catalog_object.write_xml_file(output_dir)
    catalog_pathname = output_dir.join('signatureCatalog.xml')
    catalog_pathname.read.should be_equivalent_to( <<EOF
    <?xml version="1.0" encoding="UTF-8"?>
    <signatureCatalog objectId="druid:jq937jp0017" versionId="1" catalogDatetime="2012-04-19T12:12:48Z" fileCount="11" byteCount="229690" blockCount="228">
      <entry originalVersion="1" groupId="content" storagePath="intro-1.jpg">
        <fileSignature size="41981" md5="915c0305bf50c55143f1506295dc122c" sha1="60448956fbe069979fce6a6e55dba4ce1f915178"/>
      </entry>
      <entry originalVersion="1" groupId="content" storagePath="intro-2.jpg">
        <fileSignature size="39850" md5="77f1a4efdcea6a476505df9b9fba82a7" sha1="a49ae3f3771d99ceea13ec825c9c2b73fc1a9915"/>
      </entry>
      <entry originalVersion="1" groupId="content" storagePath="page-1.jpg">
        <fileSignature size="25153" md5="3dee12fb4f1c28351c7482b76ff76ae4" sha1="906c1314f3ab344563acbbbe2c7930f08429e35b"/>
      </entry>
      <entry originalVersion="1" groupId="content" storagePath="page-2.jpg">
        <fileSignature size="39450" md5="82fc107c88446a3119a51a8663d1e955" sha1="d0857baa307a2e9efff42467b5abd4e1cf40fcd5"/>
      </entry>
      <entry originalVersion="1" groupId="content" storagePath="page-3.jpg">
        <fileSignature size="19125" md5="a5099878de7e2e064432d6df44ca8827" sha1="c0ccac433cf02a6cee89c14f9ba6072a184447a2"/>
      </entry>
      <entry originalVersion="1" groupId="content" storagePath="title.jpg">
        <fileSignature size="40873" md5="1a726cd7963bd6d3ceb10a8c353ec166" sha1="583220e0572640abcd3ddd97393d224e8053a6ad"/>
      </entry>
      <entry originalVersion="1" groupId="metadata" storagePath="contentMetadata.xml">
        <fileSignature size="1619" md5="b886db0d14508884150a916089da840f" sha1="b2328faaf25caf037cfc0263896ad707fc3a47a7"/>
      </entry>
      <entry originalVersion="1" groupId="metadata" storagePath="descMetadata.xml">
        <fileSignature size="3046" md5="a60bb487db6a1ceb5e0b5bb3cae2dfa2" sha1="edefc0e1d7cffd5bd3c7db6a393ab7632b70dc2d"/>
      </entry>
      <entry originalVersion="1" groupId="metadata" storagePath="identityMetadata.xml">
        <fileSignature size="12903" md5="ccb5bf2ae0c2c6ad0b89692fa1e10145" sha1="3badb0d06aef40f14e4664d2594c6060b9e9716b"/>
      </entry>
      <entry originalVersion="1" groupId="metadata" storagePath="provenanceMetadata.xml">
        <fileSignature size="5306" md5="17193dbf595571d728ba59aa31638db9" sha1="c8b91eacf9ad7532a42dc52b3c9cf03b4ad2c7f6"/>
      </entry>
      <entry originalVersion="1" groupId="metadata" storagePath="versionMetadata.xml">
        <fileSignature size="384" md5="f16a2564fae2706a8c82cda6dccdb4d9" sha1="7aaf84f63a1db803d272352f03935d303f066560"/>
      </entry>
    </signatureCatalog>
EOF
    )
    output_dir.rmtree
  end

end
{code}
